import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
from sensor_msgs.msg import LaserScan
import numpy as np
import threading


class SonarPotentialField(Node):

    def __init__(self, sonar_topic = '/rexrov2/sss_sonar'):
        super().__init__('potential_avoidance_node')

        self.sum_potentials_x = 0
        self.sum_potentials_y = 0
        self.Kp = .3#.9#0.05
        self.Kphi = 10#0.35
        self.sonar_sub_name = sonar_topic
        self.velocity_command_topic_name = '/rexrov2/cmd_vel'


        # Sonar Subscriber
        self.sonar_sub = self.create_subscription(LaserScan, self.sonar_sub_name, self.callback_sonar, 10)
        # Velocity publisher
        self.steering_signal = self.create_publisher(Twist, self.velocity_command_topic_name, 10)

    # Callback for the sonar topic
    def callback_sonar(self, sonar_data):
        self.get_logger().info("Scan starts in angle {:.2f} , and ends in angle {:.2f}"
               .format(sonar_data.angle_min*(180/np.pi), sonar_data.angle_max*(180/np.pi)))

        angles = np.linspace(sonar_data.angle_min, sonar_data.angle_max, num=len(sonar_data.ranges))
        potentials_x = np.multiply(1/np.asarray(sonar_data.ranges)**2, np.cos(angles))
        self.sum_potentials_x = np.sum(potentials_x)
        potentials_y = np.multiply(1/np.asarray(sonar_data.ranges)**2, np.sin(angles))
        self.sum_potentials_y = np.sum(potentials_y)
        

    def there_is_obstacle(self, range, min_dist_to_obstacle):        
        if range <= min_dist_to_obstacle:
            obstacle = True
        else:
            obstacle = False
        return obstacle

    def set_velocity_values(self, linear_x_vel):
    
        linear_x = linear_x_vel - self.Kp * self.sum_potentials_x
        # compute the angle between linear velocity and vy generated by potential obstacles
        angle = np.arctan(float(- self.Kp * self.sum_potentials_y/linear_x))
        # Turn
        msg = Twist()
        msg.linear.x = linear_x
        msg.angular.z = self.Kphi*angle

        self.steering_signal.publish(msg)
       



def main(args=None):
    rclpy.init(args=args)
    avoid_boi = SonarPotentialField(sonar_topic = '/rexrov2/sss_sonar')
    node = rclpy.create_node('minimal_publisher')
    # Spin in a separate thread
    thread = threading.Thread(target=rclpy.spin, args=(node, ), daemon=True)
    thread.start()

    rate = node.create_rate(8) # 8hz

    try:
        while rclpy.ok():
            avoid_boi.set_velocity_values(0.9)
            rate.sleep()
    except KeyboardInterrupt:
        pass

    rclpy.shutdown()
    thread.join()

if __name__ == '__main__':
    main()